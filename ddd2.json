[
  {
    "id": "F01",
    "title": "主进程架构",
    "description": "主进程架构尚未按需求文档所规划的方式实现。目前的实现未体现预期的模块化主进程设计，各主要服务未被划分为独立模块/进程，缺少统一的主进程框架结构。",
    "reason": "良好的主进程架构可保证应用稳定和模块隔离。需求文档要求在主进程层面解耦各功能模块，实现清晰的分层与调度，但仓库现状仍较为单体，缺少独立的管理模块（近期才开始新增“直播管理”等模块:contentReference[oaicite:0]{index=0}），导致各部分耦合度较高。",
    "design": "将 Electron 主进程改造成模块化架构。在应用启动时创建独立的后台服务模块（如数据处理服务、插件管理服务等）作为子进程或独立线程运行，通过 IPC 消息总线与主进程通信。主进程作为调度中心，负责启动/停止各模块并统一转发事件。此外，应定义明确的模块接口和生命周期管理，使各部分解耦运行，各模块故障不影响主流程。",
    "depends_on": []
  },
  {
    "id": "F02",
    "title": "WS统一转发",
    "description": "WebSocket 统一转发机制尚未实现，缺少将不同实时事件源整合并通过单一 WebSocket 信道转发的功能模块。",
    "reason": "统一的 WebSocket 转发有助于简化实时数据分发，避免多个组件各自维护连接:contentReference[oaicite:1]{index=1}。需求说明要求通过单一路径广播弹幕、礼物等所有事件，方便前端 Overlay 或插件统一订阅。但目前仓库中各事件源可能由各模块直接处理，缺乏集中转发，增加了管理复杂度。",
    "design": "在主进程中实现一个 WebSocket Hub 服务:contentReference[oaicite:2]{index=2}。该 Hub 创建单一 WebSocket 服务器供本地页面或插件连接订阅，内部汇聚所有事件。各内部事件源（弹幕消息、礼物通知、用户进场等）统一发布标准化事件给 Hub，由 Hub 广播给所有 WS 客户端。采用发布-订阅模式按事件类型分发，定义统一的消息格式和协议，确保不同事件经由此单一路径传递给前端 Overlay 等组件。",
    "depends_on": [
      "F01"
    ]
  },
  {
    "id": "F03",
    "title": "Overlay token 管理",
    "description": "Overlay Token 管理功能缺失，目前没有机制为 Overlay 页面生成和校验安全令牌。",
    "reason": "缺少令牌机制会导致 Overlay 接口缺乏访问控制，存在安全隐患。OBS 中使用的 Overlay 网页若无鉴权，可能被他人探知端口后任意连接获取直播数据。引入 token 可确保只有持有正确令牌的客户端才能订阅数据。需求文档强调对 Overlay 接口的鉴权管理，但仓库实现虽已增加 Overlay 系统:contentReference[oaicite:3]{index=3}却没有 token 验证支持。",
    "design": "实现 Overlay 访问的令牌生成与验证机制。应用启动时生成高强度随机令牌并保存（可持久化于配置）。Overlay 页面 URL 需要携带该 token（如作为查询参数或请求头），本地服务器在收到请求或 WebSocket 连接时校验令牌，匹配方可返回数据。提供用户界面操作以重置令牌（重置后 OBS Overlay URL 需更新）。令牌应采用加密随机生成，长度足够防猜测，并确保日志不暴露令牌值，从而提升 Overlay 服务接口的安全性。",
    "depends_on": [
      "F02",
      "F04"
    ]
  },
  {
    "id": "F04",
    "title": "Express 路由",
    "description": "Express 路由（内置 HTTP 服务）尚未完整实现，当前应用缺少提供本地网页和接口的 HTTP 服务端和路由配置。",
    "reason": "内置 HTTP 服务支持 Overlay 页面加载和外部集成 API，是需求文档的重要部分。如果没有 Express 路由，本地控制台页面、OBS Overlay 页面等功能将无法通过HTTP提供:contentReference[oaicite:4]{index=4}。目前仓库仅初步集成了部分 HTTP API（数据站接口），但尚未形成完善的路由体系，无法满足完整需求。",
    "design": "在主进程中集成 Express（或类似的）服务器:contentReference[oaicite:5]{index=5}并定义清晰的路由：包括静态文件路由用于提供 Overlay 前端页面资源（例如 `GET /overlay` 返回页面），以及 REST API 路由用于工具箱功能（如 `GET /api/status` 获取状态、`POST /api/plugins/{id}/enable` 控制插件启用等）。路由设计需覆盖需求文档中的各项功能接口。服务器应在应用启动时监听配置指定的本地端口，并在应用退出时正常关闭。对于关键写操作路由可考虑本地访问限制或简单鉴权，以确保安全。",
    "depends_on": [
      "F01"
    ]
  },
  {
    "id": "F05",
    "title": "插件机制粒度",
    "description": "插件机制的粒度不足，当前系统无法按照需求将功能细分为更小的独立插件。",
    "reason": "更细粒度的插件划分便于按需启用或停用特定功能，降低耦合度并提升维护性。需求说明希望各独立功能模块（如弹幕上墙、礼物通知）作为独立插件存在。但目前工具箱的插件系统仍较为粗放，多个功能耦合在一起或插件边界模糊:contentReference[oaicite:6]{index=6}，难以灵活增减单项功能。",
    "design": "改进插件框架以支持更细小的插件单元。为插件制定清晰的接口和边界，使每个插件只承担单一职责。可以引入插件清单（manifest）来描述插件名称、版本、依赖和可处理的事件类型等。在应用启动时逐个加载插件，根据清单注册其事件监听和提供的功能接口:contentReference[oaicite:7]{index=7}。重构配置管理，将每个插件的配置独立存储，前端提供界面让用户单独启用/禁用某插件。通过提高插件粒度，主播可自由组合所需功能插件，而停用某个插件不会影响其他插件的运行。",
    "depends_on": [
      "F01"
    ]
  },
  {
    "id": "F06",
    "title": "配置升级策略",
    "description": "配置文件的升级兼容策略尚未实现，应用在版本更新时缺乏针对旧配置的自动迁移机制。",
    "reason": "随着工具箱版本更新，配置格式和选项可能变化。如果没有升级策略，用户升级后可能遇到配置不兼容、需要手动重置的问题。需求规格要求应用能检测旧版配置并自动迁移至新格式，保证向后兼容。但当前仓库中未见配置版本检测或迁移处理逻辑，表明此功能尚未实现。",
    "design": "实现配置文件的版本管理与迁移策略。在配置文件中增加格式版本号，每次启动时检查当前软件所需的配置版本。如果检测到旧版本配置，则执行对应的升级步骤：例如填充新增字段的默认值，将重命名或改动的字段转换为新格式，移除废弃字段等。可针对每个历史版本维护迁移函数链，按顺序将配置升级到最新版本。在迁移前备份原配置文件，以便出错时还原。通过该策略，用户在软件升级后原有设置能够被平滑保留，无需手工调整。",
    "depends_on": []
  },
  {
    "id": "F07",
    "title": "SQLite 写入策略",
    "description": "缺少针对 SQLite 数据库写入的优化策略。当前实现未提供批量、异步写入机制来高效存储弹幕及日志数据。",
    "reason": "高效写入 SQLite 对于实时存储大量弹幕/事件数据非常重要。如果逐条同步写入，每条弹幕都会触发磁盘I/O，可能造成性能瓶颈和界面卡顿。需求说明建议采用缓冲队列、异步批量等策略优化写入吞吐。但目前仓库中没有专门的写入管理模块，也无commit记录提及批量提交或队列机制，说明这一优化尚未落实。",
    "design": "实现异步批量写入 SQLite 的策略。引入内存队列缓冲新弹幕/事件，避免立即写盘。启动独立的写入线程或定时任务，每隔固定时间或当队列累计到一定数量时，将多条事件一起开启事务写入数据库。利用事务批处理提高写入效率，减少磁盘频繁访问。同时在应用退出前确保将剩余缓冲数据全部提交。该策略可以通过配置调整缓冲大小和写入间隔，以平衡数据实时性和系统性能。通过异步批量写入，确保大量数据记录的同时不会阻塞主线程，提升整体性能与稳定性。",
    "depends_on": [
      "F08"
    ]
  },
  {
    "id": "F08",
    "title": "弹幕事件标准化",
    "description": "弹幕及直播事件数据缺乏标准化处理，不同类型事件（弹幕、礼物、进场等）的数据结构目前不统一。",
    "reason": "将不同类型的直播事件统一格式可以简化插件开发和事件处理流程。需求文档希望所有事件遵循统一的数据结构（包含通用字段，如时间戳、用户、类型、内容等），方便统一处理:contentReference[oaicite:8]{index=8}。若无标准化，各插件需分别解析不同格式的数据，增加复杂度和错误风险。目前仓库虽已引入 AcFun 弹幕数据模块:contentReference[oaicite:9]{index=9}，但尚未将其与其他事件统一转换为标准格式，表明此标准化步骤仍未完成。",
    "design": "制定统一的事件数据结构。例如可定义每个事件包含类型（如弹幕、礼物、入场等）、时间戳、用户信息以及内容详情等字段。实现一个转换层，在各数据源模块获取事件后，将不同来源的原始数据映射为标准事件对象再向下传递:contentReference[oaicite:10]{index=10}。WsHub 或事件分发中心应以标准对象为单位广播事件，让所有插件和存储逻辑使用统一格式。建议借助 TypeScript 接口或 JSON Schema 明确定义事件格式，并在开发文档中注明各字段含义，确保开发者使用一致的数据结构。",
    "depends_on": [
      "F02"
    ]
  },
  {
    "id": "F09",
    "title": "插件隔离与熔断机制",
    "description": "插件运行缺乏隔离沙盒及熔断保护机制。当前插件皆在同一进程中执行，发生异常时不会自动隔离或停止。",
    "reason": "没有隔离，单个插件的崩溃可能导致整个应用崩溃或卡顿:contentReference[oaicite:11]{index=11}。需求规定每个插件应在沙盒或独立进程中运行，并设置熔断策略以在插件异常或资源滥用时自动停用该插件。现有设计虽然增加了插件错误日志等处理:contentReference[oaicite:12]{index=12}，但插件仍共享进程，缺乏对异常插件的主动隔离与关闭措施，整体稳定性存在隐患。",
    "design": "通过为每个插件提供独立的运行环境来实现隔离。例如使用 Node.js 的子进程或 Worker 线程让插件代码在独立进程/线程中执行，通过 IPC 与主进程通信。这样某插件崩溃或死循环时，不会阻塞主应用，可以选择重启或卸载该插件。建立插件熔断监控机制：监视每个插件的异常次数、执行耗时和资源占用。如果某插件在短时间内连续多次出错或占用资源超限，则触发熔断——自动暂停该插件的运行并在界面警告用户。熔断后用户可手动重启插件。通过插件隔离与熔断设计，即使单个插件故障也不会影响整个工具箱的稳定运行。",
    "depends_on": [
      "F01",
      "F05"
    ]
  }
]
