# æ€§èƒ½ç›‘æ§å’Œè°ƒè¯•æŒ‡å—

## æ¦‚è¿°

æœ¬æŒ‡å—è¯¦ç»†ä»‹ç»äº†å¦‚ä½•åœ¨ AcFun Live Toolbox MKII ä¸­ç›‘æ§æ’ä»¶æ€§èƒ½ã€è¯Šæ–­æ€§èƒ½é—®é¢˜å’Œè¿›è¡Œæ€§èƒ½è°ƒè¯•ã€‚é€šè¿‡æœ¬æŒ‡å—ï¼Œå¼€å‘è€…å¯ä»¥æœ‰æ•ˆåœ°è¯†åˆ«å’Œè§£å†³æ€§èƒ½ç“¶é¢ˆã€‚

## æ€§èƒ½ç›‘æ§ç³»ç»Ÿæ¶æ„

### ç›‘æ§ç»„ä»¶æ¦‚è§ˆ

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ€§èƒ½ç›‘æ§ç³»ç»Ÿ                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  PluginPerformanceMonitor (æ ¸å¿ƒç›‘æ§å™¨)                      â”‚
â”‚  â”œâ”€â”€ å®æ—¶æŒ‡æ ‡æ”¶é›†                                           â”‚
â”‚  â”œâ”€â”€ é˜ˆå€¼æ£€æŸ¥å’Œå‘Šè­¦                                         â”‚
â”‚  â”œâ”€â”€ å†å²æ•°æ®ç®¡ç†                                           â”‚
â”‚  â””â”€â”€ æ€§èƒ½æŠ¥å‘Šç”Ÿæˆ                                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  èµ„æºç›‘æ§ç»„ä»¶                                               â”‚
â”‚  â”œâ”€â”€ MemoryPoolManager (å†…å­˜ç›‘æ§)                          â”‚
â”‚  â”œâ”€â”€ ConnectionPoolManager (è¿æ¥ç›‘æ§)                      â”‚
â”‚  â”œâ”€â”€ PluginCacheManager (ç¼“å­˜ç›‘æ§)                         â”‚
â”‚  â””â”€â”€ PluginLazyLoader (åŠ è½½ç›‘æ§)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  æ•°æ®æ”¶é›†å’Œåˆ†æ                                             â”‚
â”‚  â”œâ”€â”€ æŒ‡æ ‡èšåˆ                                               â”‚
â”‚  â”œâ”€â”€ è¶‹åŠ¿åˆ†æ                                               â”‚
â”‚  â”œâ”€â”€ å¼‚å¸¸æ£€æµ‹                                               â”‚
â”‚  â””â”€â”€ æ€§èƒ½åŸºå‡†å¯¹æ¯”                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ç›‘æ§æŒ‡æ ‡è¯¦è§£

### 1. å†…å­˜ä½¿ç”¨æŒ‡æ ‡

#### ç›‘æ§é¡¹ç›®
- **å †å†…å­˜ä½¿ç”¨é‡** (Heap Used)
- **å †å†…å­˜æ€»é‡** (Heap Total)
- **å¤–éƒ¨å†…å­˜ä½¿ç”¨** (External Memory)
- **å†…å­˜å¢é•¿ç‡** (Memory Growth Rate)
- **å†…å­˜å³°å€¼** (Peak Memory Usage)

#### è·å–å†…å­˜æŒ‡æ ‡

```typescript
import { PluginPerformanceMonitor } from '../plugins/PluginPerformanceMonitor';

const monitor = PluginPerformanceMonitor.getInstance();
const pluginId = 'my-plugin';

// å¼€å§‹ç›‘æ§
monitor.startMonitoring(pluginId);

// è®°å½•å†…å­˜ä½¿ç”¨
function recordMemoryUsage() {
  const memUsage = process.memoryUsage();
  
  // è®°å½•å †å†…å­˜ä½¿ç”¨
  monitor.recordMemoryUsage(pluginId, memUsage.heapUsed);
  
  // è®°å½•è¯¦ç»†å†…å­˜ä¿¡æ¯
  console.log('å†…å­˜ä½¿ç”¨è¯¦æƒ…:');
  console.log(`- å †å·²ä½¿ç”¨: ${(memUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`);
  console.log(`- å †æ€»é‡: ${(memUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`);
  console.log(`- å¤–éƒ¨å†…å­˜: ${(memUsage.external / 1024 / 1024).toFixed(2)} MB`);
  console.log(`- RSS: ${(memUsage.rss / 1024 / 1024).toFixed(2)} MB`);
}

// å®šæœŸè®°å½•å†…å­˜ä½¿ç”¨
setInterval(recordMemoryUsage, 5000);
```

#### å†…å­˜ç›‘æ§å‘Šè­¦

```typescript
// è®¾ç½®å†…å­˜ä½¿ç”¨é˜ˆå€¼
const memoryThreshold = 100 * 1024 * 1024; // 100MB

function checkMemoryUsage() {
  const metrics = monitor.getMetrics(pluginId);
  
  if (metrics.currentMemoryUsage > memoryThreshold) {
    console.warn(`âš ï¸  æ’ä»¶ ${pluginId} å†…å­˜ä½¿ç”¨è¶…è¿‡é˜ˆå€¼:`);
    console.warn(`   å½“å‰ä½¿ç”¨: ${(metrics.currentMemoryUsage / 1024 / 1024).toFixed(2)} MB`);
    console.warn(`   é˜ˆå€¼: ${(memoryThreshold / 1024 / 1024).toFixed(2)} MB`);
    
    // è§¦å‘å†…å­˜æ¸…ç†
    await triggerMemoryCleanup();
  }
  
  // æ£€æŸ¥å†…å­˜å¢é•¿è¶‹åŠ¿
  if (metrics.memoryGrowthRate > 0.1) { // 10%å¢é•¿ç‡
    console.warn(`âš ï¸  æ’ä»¶ ${pluginId} å†…å­˜å¢é•¿è¿‡å¿«: ${(metrics.memoryGrowthRate * 100).toFixed(2)}%/åˆ†é’Ÿ`);
  }
}

async function triggerMemoryCleanup() {
  // æ¸…ç†æ’ä»¶ç¼“å­˜
  const cacheManager = PluginCacheManager.getInstance();
  cacheManager.clearPluginCache(pluginId);
  
  // è§¦å‘åƒåœ¾å›æ”¶
  if (global.gc) {
    global.gc();
  }
  
  console.log('âœ… å†…å­˜æ¸…ç†å®Œæˆ');
}
```

### 2. CPUä½¿ç”¨æŒ‡æ ‡

#### ç›‘æ§é¡¹ç›®
- **CPUä½¿ç”¨ç‡** (CPU Usage Percentage)
- **ç”¨æˆ·æ€æ—¶é—´** (User CPU Time)
- **ç³»ç»Ÿæ€æ—¶é—´** (System CPU Time)
- **CPUå³°å€¼ä½¿ç”¨** (Peak CPU Usage)

#### CPUç›‘æ§å®ç°

```typescript
class CPUMonitor {
  private lastCpuUsage: NodeJS.CpuUsage | null = null;
  private lastTimestamp: number = 0;
  
  startCPUMonitoring(pluginId: string) {
    this.lastCpuUsage = process.cpuUsage();
    this.lastTimestamp = Date.now();
    
    setInterval(() => {
      this.recordCPUUsage(pluginId);
    }, 1000);
  }
  
  private recordCPUUsage(pluginId: string) {
    const currentCpuUsage = process.cpuUsage(this.lastCpuUsage);
    const currentTimestamp = Date.now();
    const timeDiff = currentTimestamp - this.lastTimestamp;
    
    // è®¡ç®—CPUä½¿ç”¨ç‡ (å¾®ç§’è½¬æ¢ä¸ºç™¾åˆ†æ¯”)
    const userCpuPercent = (currentCpuUsage.user / 1000 / timeDiff) * 100;
    const systemCpuPercent = (currentCpuUsage.system / 1000 / timeDiff) * 100;
    const totalCpuPercent = userCpuPercent + systemCpuPercent;
    
    // è®°å½•CPUä½¿ç”¨ç‡
    monitor.recordCpuUsage(pluginId, totalCpuPercent);
    
    // æ›´æ–°åŸºå‡†å€¼
    this.lastCpuUsage = process.cpuUsage();
    this.lastTimestamp = currentTimestamp;
    
    // æ£€æŸ¥CPUä½¿ç”¨å‘Šè­¦
    if (totalCpuPercent > 80) {
      console.warn(`âš ï¸  æ’ä»¶ ${pluginId} CPUä½¿ç”¨ç‡è¿‡é«˜: ${totalCpuPercent.toFixed(2)}%`);
    }
  }
}
```

### 3. å“åº”æ—¶é—´æŒ‡æ ‡

#### ç›‘æ§é¡¹ç›®
- **å¹³å‡å“åº”æ—¶é—´** (Average Response Time)
- **å“åº”æ—¶é—´åˆ†å¸ƒ** (Response Time Distribution)
- **95%åˆ†ä½æ•°å“åº”æ—¶é—´** (95th Percentile)
- **æœ€å¤§å“åº”æ—¶é—´** (Max Response Time)

#### å“åº”æ—¶é—´ç›‘æ§

```typescript
// è£…é¥°å™¨æ–¹å¼ç›‘æ§æ–¹æ³•å“åº”æ—¶é—´
function MonitorResponseTime(pluginId: string) {
  return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    
    descriptor.value = async function (...args: any[]) {
      const startTime = process.hrtime.bigint();
      const startTimestamp = Date.now();
      
      try {
        const result = await method.apply(this, args);
        
        // è®¡ç®—å“åº”æ—¶é—´
        const endTime = process.hrtime.bigint();
        const responseTime = Number(endTime - startTime) / 1000000; // è½¬æ¢ä¸ºæ¯«ç§’
        
        // è®°å½•å“åº”æ—¶é—´
        monitor.recordResponseTime(pluginId, responseTime);
        
        // è®°å½•è¯¦ç»†ä¿¡æ¯
        console.log(`ğŸ“Š ${propertyName} å“åº”æ—¶é—´: ${responseTime.toFixed(2)}ms`);
        
        return result;
      } catch (error) {
        // è®°å½•é”™è¯¯å’Œå“åº”æ—¶é—´
        const endTime = process.hrtime.bigint();
        const responseTime = Number(endTime - startTime) / 1000000;
        
        monitor.recordResponseTime(pluginId, responseTime);
        monitor.recordError(pluginId, error);
        
        console.error(`âŒ ${propertyName} æ‰§è¡Œå¤±è´¥ (${responseTime.toFixed(2)}ms):`, error.message);
        throw error;
      }
    };
  };
}

// ä½¿ç”¨ç¤ºä¾‹
class MyPlugin {
  @MonitorResponseTime('my-plugin')
  async fetchUserData(userId: number) {
    // æ¨¡æ‹ŸAPIè°ƒç”¨
    const response = await fetch(`/api/users/${userId}`);
    return response.json();
  }
  
  @MonitorResponseTime('my-plugin')
  async processLargeDataset(data: any[]) {
    // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
    return data.map(item => this.processItem(item));
  }
}
```

#### å“åº”æ—¶é—´åˆ†æ

```typescript
class ResponseTimeAnalyzer {
  static analyzeResponseTimes(pluginId: string) {
    const metrics = monitor.getMetrics(pluginId);
    const responseTimes = metrics.responseTimeHistory || [];
    
    if (responseTimes.length === 0) {
      console.log('ğŸ“Š æš‚æ— å“åº”æ—¶é—´æ•°æ®');
      return;
    }
    
    // è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
    const sorted = [...responseTimes].sort((a, b) => a - b);
    const count = sorted.length;
    const sum = sorted.reduce((a, b) => a + b, 0);
    
    const stats = {
      count,
      min: sorted[0],
      max: sorted[count - 1],
      average: sum / count,
      median: sorted[Math.floor(count / 2)],
      p95: sorted[Math.floor(count * 0.95)],
      p99: sorted[Math.floor(count * 0.99)]
    };
    
    console.log(`ğŸ“Š æ’ä»¶ ${pluginId} å“åº”æ—¶é—´ç»Ÿè®¡:`);
    console.log(`   è¯·æ±‚æ€»æ•°: ${stats.count}`);
    console.log(`   å¹³å‡å“åº”æ—¶é—´: ${stats.average.toFixed(2)}ms`);
    console.log(`   ä¸­ä½æ•°: ${stats.median.toFixed(2)}ms`);
    console.log(`   95%åˆ†ä½æ•°: ${stats.p95.toFixed(2)}ms`);
    console.log(`   99%åˆ†ä½æ•°: ${stats.p99.toFixed(2)}ms`);
    console.log(`   æœ€å°å€¼: ${stats.min.toFixed(2)}ms`);
    console.log(`   æœ€å¤§å€¼: ${stats.max.toFixed(2)}ms`);
    
    // æ€§èƒ½è¯„ä¼°
    if (stats.average > 1000) {
      console.warn('âš ï¸  å¹³å‡å“åº”æ—¶é—´è¿‡é•¿ï¼Œå»ºè®®ä¼˜åŒ–');
    }
    
    if (stats.p95 > 2000) {
      console.warn('âš ï¸  95%åˆ†ä½æ•°å“åº”æ—¶é—´è¿‡é•¿ï¼Œå­˜åœ¨æ€§èƒ½ç“¶é¢ˆ');
    }
    
    return stats;
  }
}
```

### 4. é”™è¯¯ç‡æŒ‡æ ‡

#### ç›‘æ§é¡¹ç›®
- **æ€»é”™è¯¯æ•°** (Total Errors)
- **é”™è¯¯ç‡** (Error Rate)
- **é”™è¯¯ç±»å‹åˆ†å¸ƒ** (Error Type Distribution)
- **é”™è¯¯è¶‹åŠ¿** (Error Trend)

#### é”™è¯¯ç›‘æ§å®ç°

```typescript
class ErrorMonitor {
  private errorCategories = new Map<string, number>();
  
  recordError(pluginId: string, error: Error, context?: any) {
    // è®°å½•åˆ°æ€§èƒ½ç›‘æ§å™¨
    monitor.recordError(pluginId, error);
    
    // åˆ†ç±»é”™è¯¯
    const errorType = this.categorizeError(error);
    this.errorCategories.set(errorType, (this.errorCategories.get(errorType) || 0) + 1);
    
    // è®°å½•è¯¦ç»†é”™è¯¯ä¿¡æ¯
    console.error(`âŒ æ’ä»¶ ${pluginId} å‘ç”Ÿé”™è¯¯:`);
    console.error(`   ç±»å‹: ${errorType}`);
    console.error(`   æ¶ˆæ¯: ${error.message}`);
    console.error(`   å †æ ˆ: ${error.stack}`);
    
    if (context) {
      console.error(`   ä¸Šä¸‹æ–‡:`, context);
    }
    
    // æ£€æŸ¥é”™è¯¯ç‡å‘Šè­¦
    this.checkErrorRateAlert(pluginId);
  }
  
  private categorizeError(error: Error): string {
    if (error.name === 'TypeError') return 'TYPE_ERROR';
    if (error.name === 'ReferenceError') return 'REFERENCE_ERROR';
    if (error.message.includes('timeout')) return 'TIMEOUT_ERROR';
    if (error.message.includes('network')) return 'NETWORK_ERROR';
    if (error.message.includes('permission')) return 'PERMISSION_ERROR';
    return 'UNKNOWN_ERROR';
  }
  
  private checkErrorRateAlert(pluginId: string) {
    const metrics = monitor.getMetrics(pluginId);
    
    if (metrics.errorRate > 0.05) { // 5%é”™è¯¯ç‡
      console.warn(`âš ï¸  æ’ä»¶ ${pluginId} é”™è¯¯ç‡è¿‡é«˜: ${(metrics.errorRate * 100).toFixed(2)}%`);
      
      // ç”Ÿæˆé”™è¯¯æŠ¥å‘Š
      this.generateErrorReport(pluginId);
    }
  }
  
  generateErrorReport(pluginId: string) {
    console.log(`ğŸ“‹ æ’ä»¶ ${pluginId} é”™è¯¯æŠ¥å‘Š:`);
    console.log('   é”™è¯¯ç±»å‹åˆ†å¸ƒ:');
    
    for (const [type, count] of this.errorCategories.entries()) {
      console.log(`   - ${type}: ${count}æ¬¡`);
    }
    
    const metrics = monitor.getMetrics(pluginId);
    console.log(`   æ€»é”™è¯¯æ•°: ${metrics.errorCount}`);
    console.log(`   é”™è¯¯ç‡: ${(metrics.errorRate * 100).toFixed(2)}%`);
  }
}
```

## èµ„æºç›‘æ§

### 1. å†…å­˜æ± ç›‘æ§

```typescript
class MemoryPoolMonitor {
  static monitorMemoryPool() {
    const memoryPool = MemoryPoolManager.getInstance();
    
    setInterval(() => {
      const stats = memoryPool.getStats();
      
      console.log('ğŸ§  å†…å­˜æ± çŠ¶æ€:');
      console.log(`   æ€»å®¹é‡: ${(stats.total / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   å·²ä½¿ç”¨: ${(stats.used / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   ä½¿ç”¨ç‡: ${(stats.used / stats.total * 100).toFixed(2)}%`);
      console.log(`   ç¢ç‰‡ç‡: ${(stats.fragmentation * 100).toFixed(2)}%`);
      console.log(`   åˆ†é…æ¬¡æ•°: ${stats.allocations}`);
      console.log(`   é‡Šæ”¾æ¬¡æ•°: ${stats.deallocations}`);
      
      // å‘Šè­¦æ£€æŸ¥
      if (stats.used / stats.total > 0.9) {
        console.warn('âš ï¸  å†…å­˜æ± ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå»ºè®®æ¸…ç†æˆ–æ‰©å®¹');
      }
      
      if (stats.fragmentation > 0.3) {
        console.warn('âš ï¸  å†…å­˜ç¢ç‰‡ç‡è¿‡é«˜ï¼Œå»ºè®®è¿›è¡Œç¢ç‰‡æ•´ç†');
        memoryPool.defragment();
      }
    }, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
  }
}
```

### 2. è¿æ¥æ± ç›‘æ§

```typescript
class ConnectionPoolMonitor {
  static monitorConnectionPool() {
    const connectionPool = ConnectionPoolManager.getInstance();
    
    setInterval(() => {
      const stats = connectionPool.getStats();
      
      console.log('ğŸ”— è¿æ¥æ± çŠ¶æ€:');
      console.log(`   æ€»è¿æ¥æ•°: ${stats.totalConnections}`);
      console.log(`   æ´»è·ƒè¿æ¥: ${stats.activeConnections}`);
      console.log(`   ç©ºé—²è¿æ¥: ${stats.idleConnections}`);
      console.log(`   ä½¿ç”¨ç‡: ${(stats.activeConnections / stats.totalConnections * 100).toFixed(2)}%`);
      
      // æŒ‰ç±»å‹ç»Ÿè®¡
      console.log('   è¿æ¥ç±»å‹åˆ†å¸ƒ:');
      for (const [type, count] of Object.entries(stats.connectionsByType)) {
        console.log(`   - ${type}: ${count}ä¸ª`);
      }
      
      // å‘Šè­¦æ£€æŸ¥
      if (stats.activeConnections / stats.totalConnections > 0.8) {
        console.warn('âš ï¸  è¿æ¥æ± ä½¿ç”¨ç‡è¿‡é«˜ï¼Œå»ºè®®å¢åŠ è¿æ¥æ•°æˆ–ä¼˜åŒ–è¿æ¥å¤ç”¨');
      }
      
      // å¥åº·æ£€æŸ¥
      connectionPool.healthCheck().then(unhealthyCount => {
        if (unhealthyCount > 0) {
          console.warn(`âš ï¸  å‘ç° ${unhealthyCount} ä¸ªä¸å¥åº·è¿æ¥ï¼Œå·²è‡ªåŠ¨æ¸…ç†`);
        }
      });
    }, 15000); // æ¯15ç§’æ£€æŸ¥ä¸€æ¬¡
  }
}
```

### 3. ç¼“å­˜ç›‘æ§

```typescript
class CacheMonitor {
  static monitorCache() {
    const cacheManager = PluginCacheManager.getInstance();
    
    setInterval(() => {
      const stats = cacheManager.getStats();
      
      console.log('ğŸ’¾ ç¼“å­˜çŠ¶æ€:');
      console.log(`   ç¼“å­˜é¡¹æ•°: ${stats.totalItems}`);
      console.log(`   ç¼“å­˜å¤§å°: ${(stats.totalSize / 1024 / 1024).toFixed(2)} MB`);
      console.log(`   å‘½ä¸­æ¬¡æ•°: ${stats.hits}`);
      console.log(`   æœªå‘½ä¸­æ¬¡æ•°: ${stats.misses}`);
      
      if (stats.hits + stats.misses > 0) {
        const hitRate = stats.hits / (stats.hits + stats.misses);
        console.log(`   å‘½ä¸­ç‡: ${(hitRate * 100).toFixed(2)}%`);
        
        // å‘Šè­¦æ£€æŸ¥
        if (hitRate < 0.7) {
          console.warn('âš ï¸  ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½ï¼Œå»ºè®®ä¼˜åŒ–ç¼“å­˜ç­–ç•¥');
        }
      }
      
      console.log(`   é©±é€æ¬¡æ•°: ${stats.evictions}`);
      console.log(`   è¿‡æœŸæ¬¡æ•°: ${stats.expirations}`);
      
      // å†…å­˜ä½¿ç”¨å‘Šè­¦
      if (stats.totalSize > 100 * 1024 * 1024) { // 100MB
        console.warn('âš ï¸  ç¼“å­˜å ç”¨å†…å­˜è¿‡å¤šï¼Œå»ºè®®æ¸…ç†æˆ–è°ƒæ•´ç¼“å­˜ç­–ç•¥');
      }
    }, 20000); // æ¯20ç§’æ£€æŸ¥ä¸€æ¬¡
  }
}
```

## æ€§èƒ½è¯Šæ–­å·¥å…·

### 1. ç»¼åˆæ€§èƒ½è¯Šæ–­

```typescript
class PerformanceDiagnostics {
  static async runFullDiagnosis(pluginId?: string) {
    console.log('ğŸ” å¼€å§‹æ€§èƒ½è¯Šæ–­...\n');
    
    if (pluginId) {
      await this.diagnosePlugin(pluginId);
    } else {
      await this.diagnoseAllPlugins();
    }
    
    await this.diagnoseSystemResources();
    await this.generateRecommendations();
    
    console.log('\nâœ… æ€§èƒ½è¯Šæ–­å®Œæˆ');
  }
  
  private static async diagnosePlugin(pluginId: string) {
    console.log(`ğŸ“Š è¯Šæ–­æ’ä»¶: ${pluginId}`);
    
    const metrics = monitor.getMetrics(pluginId);
    const issues = [];
    
    // å†…å­˜è¯Šæ–­
    if (metrics.currentMemoryUsage > 100 * 1024 * 1024) {
      issues.push({
        type: 'memory',
        severity: 'high',
        message: `å†…å­˜ä½¿ç”¨è¿‡é«˜: ${(metrics.currentMemoryUsage / 1024 / 1024).toFixed(2)} MB`
      });
    }
    
    // CPUè¯Šæ–­
    if (metrics.averageCpuUsage > 80) {
      issues.push({
        type: 'cpu',
        severity: 'high',
        message: `CPUä½¿ç”¨ç‡è¿‡é«˜: ${metrics.averageCpuUsage.toFixed(2)}%`
      });
    }
    
    // å“åº”æ—¶é—´è¯Šæ–­
    if (metrics.averageResponseTime > 1000) {
      issues.push({
        type: 'response_time',
        severity: 'medium',
        message: `å“åº”æ—¶é—´è¿‡é•¿: ${metrics.averageResponseTime.toFixed(2)}ms`
      });
    }
    
    // é”™è¯¯ç‡è¯Šæ–­
    if (metrics.errorRate > 0.05) {
      issues.push({
        type: 'error_rate',
        severity: 'high',
        message: `é”™è¯¯ç‡è¿‡é«˜: ${(metrics.errorRate * 100).toFixed(2)}%`
      });
    }
    
    // è¾“å‡ºè¯Šæ–­ç»“æœ
    if (issues.length === 0) {
      console.log('   âœ… æ€§èƒ½æ­£å¸¸');
    } else {
      console.log('   âš ï¸  å‘ç°æ€§èƒ½é—®é¢˜:');
      issues.forEach(issue => {
        const icon = issue.severity === 'high' ? 'ğŸ”´' : 'ğŸŸ¡';
        console.log(`   ${icon} ${issue.message}`);
      });
    }
    
    return issues;
  }
  
  private static async diagnoseAllPlugins() {
    const reports = monitor.generateReport();
    
    console.log(`ğŸ“Š è¯Šæ–­æ‰€æœ‰æ’ä»¶ (å…±${reports.length}ä¸ª):`);
    
    for (const report of reports) {
      const issues = await this.diagnosePlugin(report.pluginId);
      
      if (issues.length > 0) {
        console.log(`   æ’ä»¶ ${report.pluginId}: ${issues.length}ä¸ªé—®é¢˜`);
      }
    }
  }
  
  private static async diagnoseSystemResources() {
    console.log('\nğŸ–¥ï¸  ç³»ç»Ÿèµ„æºè¯Šæ–­:');
    
    // å†…å­˜æ± è¯Šæ–­
    const memoryPool = MemoryPoolManager.getInstance();
    const memoryStats = memoryPool.getStats();
    
    console.log('   å†…å­˜æ± :');
    console.log(`   - ä½¿ç”¨ç‡: ${(memoryStats.used / memoryStats.total * 100).toFixed(2)}%`);
    console.log(`   - ç¢ç‰‡ç‡: ${(memoryStats.fragmentation * 100).toFixed(2)}%`);
    
    if (memoryStats.fragmentation > 0.3) {
      console.log('   âš ï¸  å†…å­˜ç¢ç‰‡ç‡è¿‡é«˜');
    }
    
    // è¿æ¥æ± è¯Šæ–­
    const connectionPool = ConnectionPoolManager.getInstance();
    const connectionStats = connectionPool.getStats();
    
    console.log('   è¿æ¥æ± :');
    console.log(`   - ä½¿ç”¨ç‡: ${(connectionStats.activeConnections / connectionStats.totalConnections * 100).toFixed(2)}%`);
    console.log(`   - æ´»è·ƒè¿æ¥: ${connectionStats.activeConnections}`);
    
    if (connectionStats.activeConnections / connectionStats.totalConnections > 0.8) {
      console.log('   âš ï¸  è¿æ¥æ± ä½¿ç”¨ç‡è¿‡é«˜');
    }
    
    // ç¼“å­˜è¯Šæ–­
    const cacheManager = PluginCacheManager.getInstance();
    const cacheStats = cacheManager.getStats();
    
    console.log('   ç¼“å­˜:');
    if (cacheStats.hits + cacheStats.misses > 0) {
      const hitRate = cacheStats.hits / (cacheStats.hits + cacheStats.misses);
      console.log(`   - å‘½ä¸­ç‡: ${(hitRate * 100).toFixed(2)}%`);
      
      if (hitRate < 0.7) {
        console.log('   âš ï¸  ç¼“å­˜å‘½ä¸­ç‡è¾ƒä½');
      }
    }
    
    console.log(`   - ç¼“å­˜å¤§å°: ${(cacheStats.totalSize / 1024 / 1024).toFixed(2)} MB`);
  }
  
  private static async generateRecommendations() {
    console.log('\nğŸ’¡ ä¼˜åŒ–å»ºè®®:');
    
    const recommendations = [
      'å®šæœŸç›‘æ§æ’ä»¶æ€§èƒ½æŒ‡æ ‡',
      'åˆç†è®¾ç½®ç¼“å­˜TTLå’Œå¤§å°é™åˆ¶',
      'åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„èµ„æº',
      'ä½¿ç”¨è¿æ¥æ± å¤ç”¨ç½‘ç»œè¿æ¥',
      'é¿å…åœ¨ä¸»çº¿ç¨‹æ‰§è¡ŒCPUå¯†é›†å‹æ“ä½œ',
      'å®æ–½å†…å­˜æ³„æ¼æ£€æµ‹å’Œé¢„é˜²',
      'è®¾ç½®åˆç†çš„æ€§èƒ½å‘Šè­¦é˜ˆå€¼'
    ];
    
    recommendations.forEach((rec, index) => {
      console.log(`   ${index + 1}. ${rec}`);
    });
  }
}
```

### 2. æ€§èƒ½åŸºå‡†æµ‹è¯•

```typescript
class PerformanceBenchmark {
  static async runBenchmarks() {
    console.log('ğŸƒâ€â™‚ï¸ å¼€å§‹æ€§èƒ½åŸºå‡†æµ‹è¯•...\n');
    
    await this.benchmarkMemoryAllocation();
    await this.benchmarkConnectionAcquisition();
    await this.benchmarkCacheOperations();
    await this.benchmarkPluginLoading();
    
    console.log('\nâœ… æ€§èƒ½åŸºå‡†æµ‹è¯•å®Œæˆ');
  }
  
  private static async benchmarkMemoryAllocation() {
    console.log('ğŸ“Š å†…å­˜åˆ†é…åŸºå‡†æµ‹è¯•:');
    
    const memoryPool = MemoryPoolManager.getInstance();
    const iterations = 10000;
    
    // å°å—å†…å­˜åˆ†é…æµ‹è¯•
    const startTime = process.hrtime.bigint();
    const allocations = [];
    
    for (let i = 0; i < iterations; i++) {
      const allocation = await memoryPool.allocate(1024); // 1KB
      allocations.push(allocation);
    }
    
    const allocTime = Number(process.hrtime.bigint() - startTime) / 1000000;
    
    // å†…å­˜é‡Šæ”¾æµ‹è¯•
    const freeStartTime = process.hrtime.bigint();
    
    for (const allocation of allocations) {
      memoryPool.free(allocation);
    }
    
    const freeTime = Number(process.hrtime.bigint() - freeStartTime) / 1000000;
    
    console.log(`   ${iterations}æ¬¡1KBåˆ†é…: ${allocTime.toFixed(2)}ms (${(allocTime / iterations).toFixed(4)}ms/æ¬¡)`);
    console.log(`   ${iterations}æ¬¡é‡Šæ”¾: ${freeTime.toFixed(2)}ms (${(freeTime / iterations).toFixed(4)}ms/æ¬¡)`);
  }
  
  private static async benchmarkConnectionAcquisition() {
    console.log('ğŸ“Š è¿æ¥è·å–åŸºå‡†æµ‹è¯•:');
    
    const connectionPool = ConnectionPoolManager.getInstance();
    const iterations = 1000;
    
    const startTime = process.hrtime.bigint();
    const connections = [];
    
    for (let i = 0; i < iterations; i++) {
      const conn = await connectionPool.acquire('http', {
        url: `http://test${i % 10}.com`
      });
      connections.push(conn);
    }
    
    const acquireTime = Number(process.hrtime.bigint() - startTime) / 1000000;
    
    // é‡Šæ”¾è¿æ¥
    const releaseStartTime = process.hrtime.bigint();
    
    for (const conn of connections) {
      connectionPool.release(conn.id);
    }
    
    const releaseTime = Number(process.hrtime.bigint() - releaseStartTime) / 1000000;
    
    console.log(`   ${iterations}æ¬¡è¿æ¥è·å–: ${acquireTime.toFixed(2)}ms (${(acquireTime / iterations).toFixed(4)}ms/æ¬¡)`);
    console.log(`   ${iterations}æ¬¡è¿æ¥é‡Šæ”¾: ${releaseTime.toFixed(2)}ms (${(releaseTime / iterations).toFixed(4)}ms/æ¬¡)`);
  }
  
  private static async benchmarkCacheOperations() {
    console.log('ğŸ“Š ç¼“å­˜æ“ä½œåŸºå‡†æµ‹è¯•:');
    
    const cacheManager = PluginCacheManager.getInstance();
    const iterations = 10000;
    
    // ç¼“å­˜è®¾ç½®æµ‹è¯•
    const setStartTime = process.hrtime.bigint();
    
    for (let i = 0; i < iterations; i++) {
      cacheManager.set(`benchmark-key-${i}`, {
        data: `value-${i}`,
        timestamp: Date.now()
      });
    }
    
    const setTime = Number(process.hrtime.bigint() - setStartTime) / 1000000;
    
    // ç¼“å­˜è·å–æµ‹è¯•
    const getStartTime = process.hrtime.bigint();
    
    for (let i = 0; i < iterations; i++) {
      cacheManager.get(`benchmark-key-${i}`);
    }
    
    const getTime = Number(process.hrtime.bigint() - getStartTime) / 1000000;
    
    console.log(`   ${iterations}æ¬¡ç¼“å­˜è®¾ç½®: ${setTime.toFixed(2)}ms (${(setTime / iterations).toFixed(4)}ms/æ¬¡)`);
    console.log(`   ${iterations}æ¬¡ç¼“å­˜è·å–: ${getTime.toFixed(2)}ms (${(getTime / iterations).toFixed(4)}ms/æ¬¡)`);
  }
  
  private static async benchmarkPluginLoading() {
    console.log('ğŸ“Š æ’ä»¶åŠ è½½åŸºå‡†æµ‹è¯•:');
    
    const lazyLoader = PluginLazyLoader.getInstance();
    const pluginCount = 100;
    
    // æ³¨å†Œæ’ä»¶
    const registerStartTime = process.hrtime.bigint();
    
    for (let i = 0; i < pluginCount; i++) {
      lazyLoader.registerPlugin(`benchmark-plugin-${i}`, {
        priority: 'normal',
        loader: async (pluginId) => {
          // æ¨¡æ‹Ÿæ’ä»¶åŠ è½½
          await new Promise(resolve => setTimeout(resolve, 1));
          return { id: pluginId, loaded: true };
        }
      });
    }
    
    const registerTime = Number(process.hrtime.bigint() - registerStartTime) / 1000000;
    
    // åŠ è½½æ’ä»¶
    const loadStartTime = process.hrtime.bigint();
    
    const loadPromises = [];
    for (let i = 0; i < pluginCount; i++) {
      loadPromises.push(lazyLoader.loadPlugin(`benchmark-plugin-${i}`));
    }
    
    await Promise.all(loadPromises);
    
    const loadTime = Number(process.hrtime.bigint() - loadStartTime) / 1000000;
    
    console.log(`   ${pluginCount}ä¸ªæ’ä»¶æ³¨å†Œ: ${registerTime.toFixed(2)}ms (${(registerTime / pluginCount).toFixed(4)}ms/ä¸ª)`);
    console.log(`   ${pluginCount}ä¸ªæ’ä»¶åŠ è½½: ${loadTime.toFixed(2)}ms (${(loadTime / pluginCount).toFixed(4)}ms/ä¸ª)`);
  }
}
```

## å®æ—¶ç›‘æ§ä»ªè¡¨æ¿

### 1. æ§åˆ¶å°ä»ªè¡¨æ¿

```typescript
class PerformanceDashboard {
  private updateInterval: NodeJS.Timeout | null = null;
  
  start() {
    console.clear();
    console.log('ğŸš€ AcFun Live Toolbox MKII æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿');
    console.log('=' .repeat(60));
    
    this.updateInterval = setInterval(() => {
      this.updateDashboard();
    }, 2000);
  }
  
  stop() {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
      this.updateInterval = null;
    }
  }
  
  private updateDashboard() {
    // æ¸…å±å¹¶é‡æ–°ç»˜åˆ¶
    console.clear();
    console.log('ğŸš€ AcFun Live Toolbox MKII æ€§èƒ½ç›‘æ§ä»ªè¡¨æ¿');
    console.log('=' .repeat(60));
    console.log(`æ›´æ–°æ—¶é—´: ${new Date().toLocaleTimeString()}\n`);
    
    this.displaySystemOverview();
    this.displayPluginMetrics();
    this.displayResourceUsage();
    this.displayAlerts();
  }
  
  private displaySystemOverview() {
    const memUsage = process.memoryUsage();
    const cpuUsage = process.cpuUsage();
    
    console.log('ğŸ“Š ç³»ç»Ÿæ¦‚è§ˆ:');
    console.log(`   Node.js å†…å­˜: ${(memUsage.heapUsed / 1024 / 1024).toFixed(2)} MB / ${(memUsage.heapTotal / 1024 / 1024).toFixed(2)} MB`);
    console.log(`   RSS å†…å­˜: ${(memUsage.rss / 1024 / 1024).toFixed(2)} MB`);
    console.log(`   å¤–éƒ¨å†…å­˜: ${(memUsage.external / 1024 / 1024).toFixed(2)} MB`);
    console.log(`   è¿è¡Œæ—¶é—´: ${Math.floor(process.uptime() / 60)}åˆ†${Math.floor(process.uptime() % 60)}ç§’\n`);
  }
  
  private displayPluginMetrics() {
    const reports = monitor.generateReport();
    
    console.log('ğŸ”Œ æ’ä»¶æ€§èƒ½ (å‰5ä¸ª):');
    
    if (reports.length === 0) {
      console.log('   æš‚æ— æ’ä»¶ç›‘æ§æ•°æ®\n');
      return;
    }
    
    // æŒ‰å†…å­˜ä½¿ç”¨æ’åº
    const sortedReports = reports
      .sort((a, b) => b.summary.currentMemoryUsage - a.summary.currentMemoryUsage)
      .slice(0, 5);
    
    for (const report of sortedReports) {
      const memory = (report.summary.currentMemoryUsage / 1024 / 1024).toFixed(2);
      const cpu = report.summary.averageCpuUsage.toFixed(1);
      const responseTime = report.summary.averageResponseTime.toFixed(2);
      const errorRate = (report.summary.errorRate * 100).toFixed(2);
      
      console.log(`   ${report.pluginId}:`);
      console.log(`     å†…å­˜: ${memory}MB | CPU: ${cpu}% | å“åº”: ${responseTime}ms | é”™è¯¯: ${errorRate}%`);
    }
    console.log();
  }
  
  private displayResourceUsage() {
    console.log('ğŸ’¾ èµ„æºä½¿ç”¨:');
    
    // å†…å­˜æ± çŠ¶æ€
    const memoryPool = MemoryPoolManager.getInstance();
    const memoryStats = memoryPool.getStats();
    const memoryUsagePercent = (memoryStats.used / memoryStats.total * 100).toFixed(1);
    
    console.log(`   å†…å­˜æ± : ${memoryUsagePercent}% (${(memoryStats.used / 1024 / 1024).toFixed(2)}MB / ${(memoryStats.total / 1024 / 1024).toFixed(2)}MB)`);
    
    // è¿æ¥æ± çŠ¶æ€
    const connectionPool = ConnectionPoolManager.getInstance();
    const connectionStats = connectionPool.getStats();
    const connectionUsagePercent = (connectionStats.activeConnections / connectionStats.totalConnections * 100).toFixed(1);
    
    console.log(`   è¿æ¥æ± : ${connectionUsagePercent}% (${connectionStats.activeConnections} / ${connectionStats.totalConnections})`);
    
    // ç¼“å­˜çŠ¶æ€
    const cacheManager = PluginCacheManager.getInstance();
    const cacheStats = cacheManager.getStats();
    const hitRate = cacheStats.hits + cacheStats.misses > 0 
      ? (cacheStats.hits / (cacheStats.hits + cacheStats.misses) * 100).toFixed(1)
      : '0.0';
    
    console.log(`   ç¼“å­˜: ${hitRate}% å‘½ä¸­ç‡ (${cacheStats.totalItems}é¡¹, ${(cacheStats.totalSize / 1024 / 1024).toFixed(2)}MB)`);
    console.log();
  }
  
  private displayAlerts() {
    const alerts = this.checkAlerts();
    
    if (alerts.length === 0) {
      console.log('âœ… æ— å‘Šè­¦');
      return;
    }
    
    console.log('âš ï¸  å‘Šè­¦ä¿¡æ¯:');
    alerts.forEach(alert => {
      const icon = alert.severity === 'high' ? 'ğŸ”´' : alert.severity === 'medium' ? 'ğŸŸ¡' : 'ğŸŸ¢';
      console.log(`   ${icon} ${alert.message}`);
    });
  }
  
  private checkAlerts(): Array<{severity: string, message: string}> {
    const alerts = [];
    
    // æ£€æŸ¥ç³»ç»Ÿå†…å­˜
    const memUsage = process.memoryUsage();
    if (memUsage.heapUsed > 500 * 1024 * 1024) { // 500MB
      alerts.push({
        severity: 'high',
        message: `ç³»ç»Ÿå†…å­˜ä½¿ç”¨è¿‡é«˜: ${(memUsage.heapUsed / 1024 / 1024).toFixed(2)}MB`
      });
    }
    
    // æ£€æŸ¥å†…å­˜æ± 
    const memoryPool = MemoryPoolManager.getInstance();
    const memoryStats = memoryPool.getStats();
    if (memoryStats.used / memoryStats.total > 0.9) {
      alerts.push({
        severity: 'medium',
        message: `å†…å­˜æ± ä½¿ç”¨ç‡è¿‡é«˜: ${(memoryStats.used / memoryStats.total * 100).toFixed(1)}%`
      });
    }
    
    // æ£€æŸ¥è¿æ¥æ± 
    const connectionPool = ConnectionPoolManager.getInstance();
    const connectionStats = connectionPool.getStats();
    if (connectionStats.activeConnections / connectionStats.totalConnections > 0.8) {
      alerts.push({
        severity: 'medium',
        message: `è¿æ¥æ± ä½¿ç”¨ç‡è¿‡é«˜: ${(connectionStats.activeConnections / connectionStats.totalConnections * 100).toFixed(1)}%`
      });
    }
    
    // æ£€æŸ¥æ’ä»¶é”™è¯¯ç‡
    const reports = monitor.generateReport();
    for (const report of reports) {
      if (report.summary.errorRate > 0.05) {
        alerts.push({
          severity: 'high',
          message: `æ’ä»¶ ${report.pluginId} é”™è¯¯ç‡è¿‡é«˜: ${(report.summary.errorRate * 100).toFixed(2)}%`
        });
      }
    }
    
    return alerts;
  }
}
```

### 2. å¯åŠ¨ç›‘æ§

```typescript
// åœ¨ä¸»ç¨‹åºä¸­å¯åŠ¨æ€§èƒ½ç›‘æ§
class PerformanceMonitoringService {
  private dashboard: PerformanceDashboard;
  private monitors: Array<{ stop: () => void }> = [];
  
  async start() {
    console.log('ğŸš€ å¯åŠ¨æ€§èƒ½ç›‘æ§æœåŠ¡...');
    
    // å¯åŠ¨å„ç§ç›‘æ§å™¨
    MemoryPoolMonitor.monitorMemoryPool();
    ConnectionPoolMonitor.monitorConnectionPool();
    CacheMonitor.monitorCache();
    
    // å¯åŠ¨ä»ªè¡¨æ¿
    this.dashboard = new PerformanceDashboard();
    this.dashboard.start();
    
    // å®šæœŸè¿è¡Œè¯Šæ–­
    const diagnosticsInterval = setInterval(() => {
      PerformanceDiagnostics.runFullDiagnosis();
    }, 300000); // æ¯5åˆ†é’Ÿ
    
    this.monitors.push({
      stop: () => clearInterval(diagnosticsInterval)
    });
    
    // å®šæœŸè¿è¡ŒåŸºå‡†æµ‹è¯•
    const benchmarkInterval = setInterval(() => {
      PerformanceBenchmark.runBenchmarks();
    }, 3600000); // æ¯å°æ—¶
    
    this.monitors.push({
      stop: () => clearInterval(benchmarkInterval)
    });
    
    console.log('âœ… æ€§èƒ½ç›‘æ§æœåŠ¡å·²å¯åŠ¨');
  }
  
  stop() {
    console.log('ğŸ›‘ åœæ­¢æ€§èƒ½ç›‘æ§æœåŠ¡...');
    
    // åœæ­¢ä»ªè¡¨æ¿
    if (this.dashboard) {
      this.dashboard.stop();
    }
    
    // åœæ­¢æ‰€æœ‰ç›‘æ§å™¨
    this.monitors.forEach(monitor => monitor.stop());
    this.monitors = [];
    
    console.log('âœ… æ€§èƒ½ç›‘æ§æœåŠ¡å·²åœæ­¢');
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const monitoringService = new PerformanceMonitoringService();

// å¯åŠ¨ç›‘æ§
await monitoringService.start();

// åœ¨ç¨‹åºé€€å‡ºæ—¶åœæ­¢ç›‘æ§
process.on('SIGINT', () => {
  monitoringService.stop();
  process.exit(0);
});
```

## æ€§èƒ½ä¼˜åŒ–å»ºè®®

### 1. å†…å­˜ä¼˜åŒ–
- ä½¿ç”¨å†…å­˜æ± å‡å°‘é¢‘ç¹åˆ†é…
- åŠæ—¶é‡Šæ”¾ä¸å†ä½¿ç”¨çš„èµ„æº
- é¿å…å†…å­˜æ³„æ¼å’Œå¾ªç¯å¼•ç”¨
- å®šæœŸè¿›è¡Œå†…å­˜ç¢ç‰‡æ•´ç†

### 2. CPUä¼˜åŒ–
- é¿å…åœ¨ä¸»çº¿ç¨‹æ‰§è¡ŒCPUå¯†é›†å‹æ“ä½œ
- ä½¿ç”¨Workerçº¿ç¨‹å¤„ç†è®¡ç®—ä»»åŠ¡
- åˆç†ä½¿ç”¨å¼‚æ­¥æ“ä½œ
- ä¼˜åŒ–ç®—æ³•å¤æ‚åº¦

### 3. ç½‘ç»œä¼˜åŒ–
- ä½¿ç”¨è¿æ¥æ± å¤ç”¨è¿æ¥
- å®æ–½è¯·æ±‚ç¼“å­˜ç­–ç•¥
- è®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
- å¤„ç†ç½‘ç»œé”™è¯¯å’Œé‡è¯•

### 4. ç¼“å­˜ä¼˜åŒ–
- æ ¹æ®æ•°æ®ç‰¹æ€§è®¾ç½®TTL
- ä½¿ç”¨LRUç­–ç•¥ç®¡ç†ç¼“å­˜
- å®æ–½ç¼“å­˜é¢„çƒ­
- ç›‘æ§ç¼“å­˜å‘½ä¸­ç‡

### 5. ç›‘æ§ä¼˜åŒ–
- è®¾ç½®åˆç†çš„ç›‘æ§é¢‘ç‡
- å®æ–½åˆ†çº§å‘Šè­¦æœºåˆ¶
- å®šæœŸç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
- å»ºç«‹æ€§èƒ½åŸºå‡†çº¿

é€šè¿‡æœ¬æŒ‡å—ï¼Œå¼€å‘è€…å¯ä»¥å…¨é¢äº†è§£å’ŒæŒæ¡ AcFun Live Toolbox MKII çš„æ€§èƒ½ç›‘æ§å’Œè°ƒè¯•æŠ€æœ¯ï¼Œæœ‰æ•ˆæå‡æ’ä»¶çš„è¿è¡Œæ•ˆç‡å’Œç¨³å®šæ€§ã€‚